# this pipeline manually releases a version by:
# merging the current branch into master
# creating release notes from the commit history on master
# creating the release tag (if it doesnâ€™t already exist) on master and pushing it
# creating a github release with the release notes
# deploying the application to production

trigger: none  # disables automatic triggering of the pipeline
pr: none       # disables automatic runs for pull requests

parameters:
- name: releaseTag                 # the tag for the release (e.g. v1.0.0)
  type: string
  default: 'v1.0.0'
  displayName: 'Enter Release Tag (e.g., v1.0.0)'

pool:
  vmImage: 'ubuntu-latest'         # use the latest ubuntu image for the agent

variables:
- group: pacman-vars
- name: MY_APP_LOCATION
  value: "/"                     # source files are located in the root
- name: MY_API_LOCATION
  value: ""                      # no API used
- name: MY_APP_ARTIFACT_LOCATION
  value: "/"                     # build output will be the root

stages:
- stage: ReleaseAndDeploy
  displayName: "Release and Deploy to Production"
  jobs:
  - job: CreateReleaseAndDeploy
    displayName: "Merge to Master, Create Release, Publish Release Notes, and Deploy"
    steps:
    # checkout the repository with full history and persist credentials for pushing
    - checkout: self
      persistCredentials: true
      fetchDepth: 0

    # merge the current branch (the one selected when manually triggering the pipeline)
    # into the master branch
    - script: |
        echo "Fetching master branch and merging $(Build.SourceBranchName) into master..."
        git fetch origin master
        git checkout master
        git merge $(Build.SourceBranchName) --no-ff -m "Merge branch $(Build.SourceBranchName) into master for release ${{ parameters.releaseTag }}"
        git push origin master
      displayName: "Merge Release Branch into Master"

    # generate release notes from master commit history since the last tag
    - script: |
        echo "Generating release notes from master branch..."
        # get the most recent tag on master, if none exists, use initial commit
        previous_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "initial commit")
        echo "Previous tag: ${previous_tag}"
        
        if [ "${previous_tag}" = "initial commit" ]; then
          echo "No previous tag found. Generating release notes from the beginning of the repository."
          git log --pretty=format:"* %s" > release_notes.txt
        else
          echo "Generating release notes from ${previous_tag} to HEAD on master."
          git log ${previous_tag}..HEAD --pretty=format:"* %s" > release_notes.txt
        fi
        
        echo "Generated Release Notes:"
        cat release_notes.txt
      displayName: "Generate Release Notes"

    # publish the release notes as a pipeline artifact
    - task: PublishBuildArtifacts@1
      displayName: "Publish Release Notes Artifact"
      inputs:
        pathToPublish: 'release_notes.txt'
        artifactName: 'release-notes'

    # create the release tag on master if it doesn't exist and push it
    - script: |
        echo "Checking out master branch for tagging..."
        git checkout master
        git fetch --tags
        
        if git rev-parse ${{ parameters.releaseTag }} >/dev/null 2>&1; then
          echo "Tag ${{ parameters.releaseTag }} already exists."
        else
          echo "Tag ${{ parameters.releaseTag }} does not exist. Creating tag..."
          git tag ${{ parameters.releaseTag }}
        fi
        
        echo "Pushing tag ${{ parameters.releaseTag }} to remote..."
        git push origin ${{ parameters.releaseTag }}
      displayName: "Create and Push Release Tag on Master"

    # create a github release using the release notes
    - script: |
        echo "Preparing to create GitHub release for tag ${{ parameters.releaseTag }} on master..."
        # escape newlines in release_notes.txt for valid json
        escaped_release_notes=$(sed ':a;N;$!ba;s/\n/\\n/g' release_notes.txt)
        echo "Creating GitHub release..."
        curl -X POST -H "Authorization: token $(GITHUB_TOKEN)" -H "Content-Type: application/json" \
          -d '{
            "tag_name": "'${{ parameters.releaseTag }}'",
            "name": "'${{ parameters.releaseTag }}'",
            "body": "'"${escaped_release_notes}"'",
            "draft": false,
            "prerelease": false,
            "target_commitish": "master"
          }' https://api.github.com/repos/danielmcr1/pacman/releases
      displayName: "Create GitHub Release"

    # deploy the application to production
    - task: AzureStaticWebApp@0
      displayName: "Deploy to Azure Static Web Apps"
      inputs:
        app_location: '$(MY_APP_LOCATION)'  # root (/)
        api_location: '$(MY_API_LOCATION)'  # no api used
        output_location: '$(MY_APP_ARTIFACT_LOCATION)'  # root
        azure_static_web_apps_api_token: '$(AZURE_STATIC_WEB_APPS_API_TOKEN_PROD)'  # deployment token
